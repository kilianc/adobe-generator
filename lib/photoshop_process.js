require('console-trace')({ always: true, right: true })var fs = require('fs'),    util = require('util'),    path = require('path'),    layerToPng = require('./layer_to_png'),    photoshop = require('./photoshop')var POOL_TIME = 500var PNG_PATH = __dirname + '/../public/images/layers/'// fancy dependency declaration, isn't it? :|var stdlib = fs.readFileSync('./lib/photoshop/stdlib.js', 'utf8')var json = fs.readFileSync('./lib/photoshop/json3.js', 'utf8')var getActiveDocumentPath = json + fs.readFileSync('./lib/photoshop/getActiveDocumentPath.js', 'utf8')var getLayerData = fs.readFileSync('./lib/photoshop/getLayerData.js', 'utf8')var getLayers = json + getLayerData + fs.readFileSync('./lib/photoshop/getLayers.js', 'utf8')var getFontList = json + fs.readFileSync('./lib/photoshop/getFontList.js', 'utf8')var photoshop = photoshop()// photoshop.log = truephotoshop.on('connect', function () {  process.send({ name: 'connect' })}).on('error', function (err) {  process.send({ name: 'error', err: err })})photoshop.connect('127.0.0.1', 49494, 'password', function () {  // subscriptions  photoshop    .subscribe('toolChanged')    .subscribe('foregroundColorChanged')    .subscribe('backgroundColorChanged')    .subscribe('documentChanged')    .subscribe('currentDocumentChanged')  photoshop.on('toolChanged', function (err, tool) {    process.send({ name: 'toolChanged', data: tool })  })  photoshop.on('foregroundColorChanged', function (err, hexColor) {    process.send({ name: 'foregroundColorChanged', data: hexColor })  })  photoshop.on('backgroundColorChanged', function (err, hexColor) {    process.send({ name: 'backgroundColorChanged', data: hexColor })  })  photoshop.on('currentDocumentChanged', function (err, documentId) {    photoshop.execute(getActiveDocumentPath, function (err, response) {      currentDocumentPath = path.resolve(JSON.parse(response.body).replace('~', process.env.HOME))      try { fs.statSync(currentDocumentPath) }      catch (err) { currentDocumentPath = '/Volumes' + currentDocumentPath }      process.send({ name: 'currentDocumentChanged', data: currentDocumentPath })    })  })  photoshop.emit('currentDocumentChanged')  photoshop.execute(getFontList, function (err, response) {    process.send({ name: 'fontList', data: response.body.split(',') })  })  photoshop.polling(getLayers, POOL_TIME, function (err, layers) {    if (err) return console.error('polling error: %s', err.message)    layers.forEach(prepareLayerData.bind(null, currentDocumentPath, PNG_PATH))    process.send({ name: 'layers', data: layers })  })})function prepareLayerData(currentDocumentPath, pngPath, layer) {  if (/\.png$/.test(layer.name)) {    layer.kind = 'LayerKind.NORMAL'  }  if (layer.kind === 'LayerKind.NORMAL') {    layerToPng(layer.id, currentDocumentPath, pngPath + layer.name, function (err) {      if (err) return      layer.isPngReady = true      process.send({ name: 'layerPngReady', data: layer.id })    })  } else if (layer.kind === 'LayerKind.TEXT') {    layer.textSize = Number(layer.textSize)  }  return layer}// process.on('message', function onMessage(message) {//   switch (message.name) {//     case 'move'://       photoshop.execute(moveLayer + '; moveLayer(' + message.data.layerId + ', ' + message.data.x + ', ' + message.data.y + ')', function (err, response) {//         console.log(err, message.data, response.body)//       })//     break//     case 'selectTool'://       if (!message.data.match(/^PSClass/)) {//         photoshop.execute(stdlib + '; Stdlib.selectTool("' + message.data + '")')//       } else {//         photoshop.execute(stdlib + '; Stdlib.selectTool(' + message.data + ')')//       }//     break//     case 'setLayerFont'://       photoshop.execute(setLayerFont + '; setLayerFont("' + message.data.layerdId + '", "' + message.data.font + '")')//     break//   }// })